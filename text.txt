okay, so I try to simulate solar system in the terminal through cli.
there are my files:
main.rs

```
mod objects;
mod system;
mod physics;
mod terminal;

use crate::system::SolarSystem;
use crate::terminal::TerminalInterface;

use crossterm::{
    event::{DisableMouseCapture, EnableMouseCapture, Event, KeyCode},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use std::time::Duration;
use lazy_static::lazy_static;
use std::io;


fn main() -> Result<(), io::Error> {

    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;

    let mut solar_system = SolarSystem::new();
    let mut terminal_interface = TerminalInterface::new()?;
    let mut paused = false;
    let mut speed = 1.0;

    loop {

        clear_screen();

        for body in &solar_system.bodies {
            print!("{} {}", body.position.x, body.position.y);
        }

        if !paused {
            solar_system.run(speed);
        }

        terminal_interface.draw(&solar_system)?;

        if let Event::Key(key) = crossterm::event::read()? {
            match key.code {
                KeyCode::Char(' ') => paused = !paused,
                KeyCode::Char('+') => speed += 0.1,
                KeyCode::Char('-') => speed -= 0.1,
                KeyCode::Char('q') => break,
                KeyCode::Char('r') => {
                    solar_system = SolarSystem::new();
                    paused = false;
                }
                _ => {}
            }
        }
        std::thread::sleep(Duration::from_millis(16)); // 60 FPS
    }

    disable_raw_mode()?;
    execute!(stdout, LeaveAlternateScreen, DisableMouseCapture)?;
    Ok(())
}

fn clear_screen() {
    print!("\x1B[2J\x1B[1;1H");
}
```
objects.rs

```
use nalgebra::{Vector2, Point2};

pub type Velocity = Vector2<f64>;
pub type Position = Point2<f64>;
pub type Mass = f64;
pub type Acceleration = Vector2<f64>;
pub type Distance = Vector2<f64>;
pub type Force = Vector2<f64>;

pub const G: f64 = 6.67428e-11; // gravitational constant, in m^3 kg^-1 s^-2
pub const AU: f64 = 1.4960e+11; // astronomical units, ~distance between sun and earth

pub trait Sim {
    fn get_name(&self) -> String;
    fn get_position(&self) -> Position;     // Point2<T>
    fn get_velocity(&self) -> Velocity;     // Vector2<T>
    fn get_mass(&self) -> f64; 
    // fn simulate(&mut self)
}

#[derive(Clone, Debug)]
pub struct CelestialObject {
    pub name: String,
    pub mass: f64,
    pub position: Point2<f64>,              // x, y coordinates
    pub velocity: Vector2<f64>,             // x, y components
    pub acceleration: Vector2<f64>
}

impl CelestialObject {
    pub fn new(name: String, mass: f64, position: Point2<f64>, velocity: Vector2<f64>, acceleration: Vector2<f64>) -> Self {
        CelestialObject {
            name,
            mass,
            position,
            velocity,
            acceleration
        }
    }
    pub fn get_distance(&self, other: &Position) -> Vector2<f64> {
        other - self.position
    }

    pub fn get_force(&self, other: &CelestialObject) -> Vector2<f64> {
        let dist = self.get_distance(&other.position);
        if dist.norm() == 0.0 {
            return Vector2::new(0.0, 0.0);
        }
        let f = (G * self.mass * other.mass) / dist.norm_squared();
        f * dist.normalize()
    } 
}

impl PartialEq for CelestialObject {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.mass == other.mass && self.position == other.position && self.velocity == other.velocity
    }
}
```
system.rs

```
use crate::objects::CelestialObject;
use crate::physics;

use nalgebra::{Point2, Vector2};


pub struct Star;
pub struct Planet;
pub struct Moon;

// Define the solar system
pub struct SolarSystem {
    pub bodies: Vec<CelestialObject>,
    pub g: f64, // gravitational constant in m^3 kg^-1 s^-2
}

impl SolarSystem {
    // Constructor to create a new solar system
    pub fn new() -> Self {
        let sun = CelestialObject::new(
            "Sun".to_string(),
            1.989e30,
            Point2::new(0.0, 0.0),
            Vector2::new(0.0, 0.0),
            Vector2::new(0.0, 0.0),
        );
        let mercury = CelestialObject::new(
            "Mercury".to_string(),
            3.302e23,
            Point2::new(57.909e9, 0.0),
            Vector2::new(0.0, 47.36e3),
            Vector2::new(0.0, 0.0),
        );
        let venus = CelestialObject::new(
            "Venus".to_string(),
            4.869e24,
            Point2::new(108.208e9, 0.0),
            Vector2::new(0.0, 35.02e3),
            Vector2::new(0.0, 0.0),
        );
        let earth = CelestialObject::new(
            "Earth".to_string(),
            5.972e24,
            Point2::new(149.596e9, 0.0),
            Vector2::new(0.0, 29.78e3),
            Vector2::new(0.0, 0.0),
        );
        let moon = CelestialObject::new(
            "Moon".to_string(),
            7.349e22,
            Point2::new(384.4e6, 0.0),
            Vector2::new(0.0, 1.022e3),
            Vector2::new(0.0, 0.0),
        );
        let mars = CelestialObject::new(
            "Mars".to_string(),
            6.419e23,
            Point2::new(227.939e9, 0.0),
            Vector2::new(0.0, 24.07e3),
            Vector2::new(0.0, 0.0),
        );
        let jupiter = CelestialObject::new(
            "Jupiter".to_string(),
            1.898e27,
            Point2::new(778.299e9, 0.0),
            Vector2::new(0.0, 13.07e3),
            Vector2::new(0.0, 0.0),
        );
        let io = CelestialObject::new(
            "Io".to_string(),
            8.931e22,
            Point2::new(426.0e6, 0.0),
            Vector2::new(0.0, 17.34e3),
            Vector2::new(0.0, 0.0),
        );
        let europa = CelestialObject::new(
            "Europa".to_string(),
            4.879e22,
            Point2::new(670.9e6, 0.0),
            Vector2::new(0.0, 13.86e3),
            Vector2::new(0.0, 0.0),
        );
        let ganymede = CelestialObject::new(
            "Ganymede".to_string(),
            3.275e23,
            Point2::new(1070.4e6, 0.0),
            Vector2::new(0.0, 10.87e3),
            Vector2::new(0.0, 0.0),
        );
        let callisto = CelestialObject::new(
            "Callisto".to_string(),
            1.075e23,
            Point2::new(1882.7e6, 0.0),
            Vector2::new(0.0, 8.22e3),
            Vector2::new(0.0, 0.0),
        );
    
        SolarSystem {
            bodies: vec![
                sun,
                mercury,
                venus,
                earth,
                moon,
                mars,
                jupiter,
                io,
                europa,
                ganymede,
                callisto,
            ],
            g: 6.67430e-11,
        }
    }

    pub fn simulate(&mut self, dt: f64, num_steps: usize) {
        physics::simulate(&mut self.bodies, dt, num_steps);
    }

    pub fn run(&mut self, dt: f64) {
        self.simulate(dt, 100);
    }
}
```
terminal.rs

```
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout},
    style::{Color, Style},
    Terminal,
    prelude::*,
};
use std::io;

use crate::system::SolarSystem;

pub struct TerminalInterface {
    terminal: Terminal<CrosstermBackend<std::io::Stdout>>,
}

impl TerminalInterface {
    // Constructor to create a new terminal interface
    pub fn new() -> Result<Self, io::Error> {
        let stdout = io::stdout();
        let backend = CrosstermBackend::new(stdout);
        let terminal = Terminal::new(backend)?;
        Ok(TerminalInterface { terminal })
    }

    // Method to draw the solar system simulation
    pub fn draw(&mut self, solar_system: &SolarSystem) -> Result<(), io::Error> {
        self.terminal.draw(|f| {
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .constraints([Constraint::Length(3), Constraint::Min(1)].as_ref())
                .split(f.area());

            let title = format!("Solar System Simulation ({} bodies)", solar_system.bodies.len());
            f.render_widget(
                ratatui::widgets::Paragraph::new(title.as_str())
                    .style(Style::default().fg(Color::Yellow))
                    .alignment(Alignment::Center),
                chunks[0],
            );

            let mut text = String::new();
            for body in &solar_system.bodies {
                text.push_str(&format!("{}: ({:.2}, {:.2})\n", body.name, body.position.x, body.position.y));
            }
            f.render_widget(
                ratatui::widgets::Paragraph::new(text.as_str())
                    .style(Style::default().fg(Color::White)),
                chunks[1],
            );

            let zoom = 1.0;     // zoom level variable
            let _simspeed = 1.0; //simulation speed variable

            for body in &solar_system.bodies {
                let x = (body.position.x * zoom) as u16;
                let y = (body.position.y * zoom) as u16;
                f.set_cursor_position(Position::from((x, y)));
                // f.print_text(body.name);
            }
        })?;

        Ok(())
    }
}
```
and physics.rs
```
use crate::objects::{CelestialObject, Velocity, Acceleration, Force};

use nalgebra::{Vector2, Point2};

pub fn calculate_force(body1: &CelestialObject, body2: &CelestialObject) -> Force {
    let dist = body1.get_distance(&body2.position);
    if dist.norm() == 0.0 {
        return Vector2::new(0.0, 0.0);
    }
    let f = (crate::objects::G * body1.mass * body2.mass) / dist.norm_squared();
    f * dist.normalize()
}

pub fn update_body(body: &mut CelestialObject, dt: f64) {
    body.velocity += body.acceleration * dt;
    body.position += body.velocity * dt;
}

pub fn simulate(bodies: &mut Vec<CelestialObject>, dt: f64, num_steps: usize) {
    for _ in 0..num_steps {
        for i in 0..bodies.len() {
            let mut force = Vector2::new(0.0, 0.0);
            for j in 0..bodies.len() {
                if i != j {
                    let other = &bodies[j];
                    let f = calculate_force(&bodies[i], other);
                    force += f;
                }
            }
            bodies[i].acceleration = force / bodies[i].mass;
            update_body(&mut bodies[i], dt);
        }
    }
}
```





working physics
use crate::objects::{Acceleration, CelestialObject, Force, Velocity};

use nalgebra::{Point2, Vector2};

pub fn calculate_force(body1: &CelestialObject, body2: &CelestialObject) -> Force {
    let dist = body1.get_distance(&body2.position);
    if dist.norm() == 0.0 {
        return Vector2::new(0.0, 0.0);
    }
    let f = (crate::objects::G * body1.mass * body2.mass) / dist.norm_squared();
    f * dist.normalize()
}

pub fn update_body(body: &mut CelestialObject, dt: f64) {
    body.velocity += body.acceleration * dt;
    body.position += body.velocity * dt;
}

pub fn simulate(bodies: &mut Vec<CelestialObject>, dt: f64, num_steps: usize) {
    for _ in 0..num_steps {
        for i in 0..bodies.len() {
            let mut force = Vector2::new(0.0, 0.0);
            for j in 0..bodies.len() {
                if i != j {
                    let other = &bodies[j];
                    let f = calculate_force(&bodies[i], other);
                    force += f;
                }
            }
            bodies[i].acceleration = force / bodies[i].mass;
            update_body(&mut bodies[i], dt);
        }
    }
}
