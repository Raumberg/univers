okay, so I'm trying to build a terminal solar system with physics and gravity implemented.
here are my files:
objects.rs

```
use crate::vec::Vec2D;

pub type Velocity = (f64, f64);
pub type Position = (f64, f64);
pub type Mass = f64;
pub type Acceleration = (f64, f64);
pub type Distance = (f64, f64);
pub type Force = (f64, f64);

pub const G: f64 = 6.67428e-11; // gravitational constant, in m^3 kg^-1 s^-2
pub const AU: f64 = 1.4960e+11; // astronomical units, ~distance between sun and earth

pub trait Sim {
    fn get_name(&self) -> String;
    fn get_position(&self) -> Position;     // Vector2<T>
    fn get_velocity(&self) -> Velocity;     // Vector2<T>
    fn get_mass(&self) -> f64; 
    // fn simulate(&mut self)
}

#[derive(Clone, Debug)]
pub struct CelestialObject {
    pub name: String,
    pub mass: f64,
    pub position: (f64, f64), // x, y coordinates
    pub velocity: (f64, f64), // x, y components
}

impl CelestialObject {
    pub fn new(name: String, mass: f64, position: (f64, f64), velocity: (f64, f64)) -> Self {
        CelestialObject {
            name,
            mass,
            position,
            velocity,
        }
    }
    pub fn get_distance(&self, other: &Position) -> Distance {
        let dx: f64 = other.0 - self.position.0;
        let dy: f64 = other.1 - self.position.1;
        (dx, dy)
    }

    pub fn get_force(&self, other: &CelestialObject) -> Force {
        let dist = self.get_distance(&other.position);
        if dist.0 == 0.0 && dist.1 == 0.0 {
            return (0.0, 0.0);
        }
        let r = (dist.0.powi(2) + dist.1.powi(2)).sqrt();
        let cos = dist.0 / r;
        let sin = dist.1 / r;
        let f = (G * self.mass * other.mass) / r.powi(2);
        let fx = f * cos;
        let fy = f * sin;
        (fx, fy)
    } 
}

impl PartialEq for CelestialObject {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.mass == other.mass && self.position == other.position && self.velocity == other.velocity
    }
}
```
physics.rs

```
use crate::objects::{CelestialObject, G, Force, Acceleration};

fn calculate_forces(bodies: &Vec<CelestialObject>) -> Vec<Force> {
    let mut forces = vec![(0.,0.); bodies.len()];
    for i in 0..bodies.len() - 1 {
        for j in i + 1..bodies.len() {
            let f = bodies[i].get_force(&bodies[j]);
            forces[i].0 += f.0;
            forces[i].1 += f.1;
            forces[j].0 += -f.0;
            forces[j].1 += -f.1;
        }
    }
    forces
}

fn calculate_accels(bodies: &Vec<CelestialObject>, forces: Vec<Force>) -> Vec<Acceleration> {
    let mut accels = vec![(0.,0.); bodies.len()];
    for i in 0..bodies.len() {
        let ax = forces[i].0 / bodies[i].mass;
        let ay = forces[i].1 / bodies[i].mass;
        accels[i] = (ax, ay);
    }
    accels
}

fn calculate_gravitational_force(body1: &CelestialObject, body2: &CelestialObject) -> (f64, f64) {
    // Calculate the distance squared between the two bodies
    let distance_squared = (body2.position.0 - body1.position.0).powi(2) + (body2.position.1 - body1.position.1).powi(2);

    // Calculate the force magnitude
    let force_magnitude = G * body1.mass * body2.mass / distance_squared;

    // Calculate the force components
    let force_x = force_magnitude * (body2.position.0 - body1.position.0) / distance_squared.sqrt();
    let force_y = force_magnitude * (body2.position.1 - body1.position.1) / distance_squared.sqrt();

    (force_x, force_y)
}

fn update_body(body: &mut CelestialObject, bodies: &[CelestialObject], dt: f64) {
    // Initialize the force components to 0
    let mut force_x = 0.0;
    let mut force_y = 0.0;

    // Calculate the total force on the body
    for other_body in bodies {
        if body != other_body {
            let (fx, fy) = calculate_gravitational_force(body, other_body);
            force_x += fx;
            force_y += fy;
        }
    }

    // Calculate the acceleration
    let acceleration_x = force_x / body.mass;
    let acceleration_y = force_y / body.mass;

    // Update the velocity and position
    body.velocity.0 += acceleration_x * dt;
    body.velocity.1 += acceleration_y * dt;
    body.position.0 += body.velocity.0 * dt;
    body.position.1 += body.velocity.1 * dt;
}

pub fn simulate(bodies: &mut [CelestialObject], dt: f64, num_steps: usize) {
    // Check if num_steps is 0
    if num_steps == 0 {
        return;
    }

    // Simulate the bodies
    for _ in 0..num_steps {
        for body in bodies.iter_mut() {
            update_body(body, bodies, dt);
        }
    }
}
```
system.rs

```
use crate::objects::CelestialObject;

pub struct Star;
pub struct Planet;
pub struct Moon;

// Define the solar system
pub struct SolarSystem {
    pub bodies: Vec<CelestialObject>,
    pub g: f64, // gravitational constant in m^3 kg^-1 s^-2
}

impl SolarSystem {
    // Constructor to create a new solar system
    pub fn new() -> Self {
        let sun = CelestialObject::new("Sun".to_string(), 1.989e30, (0.0, 0.0), (0.0, 0.0));
        let mercury = CelestialObject::new("Mercury".to_string(), 3.302e23, (57.909e9, 0.0), (0.0, 47.36e3));
        let venus = CelestialObject::new("Venus".to_string(), 4.869e24, (108.208e9, 0.0), (0.0, 35.02e3));
        let earth = CelestialObject::new("Earth".to_string(), 5.972e24, (149.596e9, 0.0), (0.0, 29.78e3));
        let moon = CelestialObject::new("Moon".to_string(), 7.349e22, (384.4e6, 0.0), (0.0, 1.022e3));
        let mars = CelestialObject::new("Mars".to_string(), 6.419e23, (227.939e9, 0.0), (0.0, 24.07e3));
        let jupiter = CelestialObject::new("Jupiter".to_string(), 1.898e27, (778.299e9, 0.0), (0.0, 13.07e3));
        let io = CelestialObject::new("Io".to_string(), 8.931e22, (426.0e6, 0.0), (0.0, 17.34e3));
        let europa = CelestialObject::new("Europa".to_string(), 4.879e22, (670.9e6, 0.0), (0.0, 13.86e3));
        let ganymede = CelestialObject::new("Ganymede".to_string(), 3.275e23, (1070.4e6, 0.0), (0.0, 10.87e3));
        let callisto = CelestialObject::new("Callisto".to_string(), 1.075e23, (1882.7e6, 0.0), (0.0, 8.22e3));

        let g = 6.67430e-11; 

        SolarSystem {
            bodies: vec![
                sun,
                mercury,
                venus,
                earth,
                moon,
                mars,
                jupiter,
                io,
                europa,
                ganymede,
                callisto,
            ],
            g
        }
    }

    pub fn simulate(&mut self, dt: f64, num_steps: usize) {
        crate::physics::simulate(&mut self.bodies, dt, num_steps);
    }

    pub fn run(&mut self, dt: f64) {
        self.simulate(dt, 100);
    }
}
```
vec.rs

```
use arrayfire::{Array, Dim4};

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub struct Vec2D<T> {
    data: Array<T>,
}

impl<T: Copy> Vec2D<T> {
    pub fn new(x: T, y: T) -> Vec2D<T> {
        Vec2D {
            data: Array::new(&[x, y], Dim4::new(&[2, 1, 1, 1])),
        }
    }

    pub fn new_zero() -> Vec2D<T> {
        Vec2D {
            data: Array::zeros(Dim4::new(&[2, 1, 1, 1])),
        }
    }

    pub fn get_x(&self) -> T {
        self.data[0]
    }

    pub fn get_y(&self) -> T {
        self.data[1]
    }

    pub fn norm(&self) -> f64 {
        (self.data[0].powi(2) + self.data[1].powi(2)).sqrt()
    }
}

impl<T: Copy> std::ops::Add for Vec2D<T> {
    type Output = Vec2D<T>;

    fn add(self, other: Vec2D<T>) -> Vec2D<T> {
        Vec2D {
            data: self.data + &other.data,
        }
    }
}

impl<T: Copy> std::ops::Sub for Vec2D<T> {
    type Output = Vec2D<T>;

    fn sub(self, other: Vec2D<T>) -> Vec2D<T> {
        Vec2D {
            data: self.data - &other.data,
        }
    }
}

impl<T: Copy> std::ops::Mul<T> for Vec2D<T> {
    type Output = Vec2D<T>;

    fn mul(self, rhs: T) -> Vec2D<T> {
        Vec2D {
            data: self.data * rhs,
        }
    }
}

impl<T: Copy> std::ops::Div<T> for Vec2D<T> {
    type Output = Vec2D<T>;

    fn div(self, rhs: T) -> Vec2D<T> {
        Vec2D {
            data: self.data / rhs,
        }
    }
}

impl<T: Copy> Vec2D<T> {
    pub fn scalar_mul(&self, rhs: T) -> Vec2D<T> {
        self * rhs
    }
}

impl<T: Copy> std::ops::Mul<Vec2D<T>> for T {
    type Output = Vec2D<T>;

    fn mul(self, rhs: Vec2D<T>) -> Vec2D<T> {
        rhs.scalar_mul(self)
    }
}
```
